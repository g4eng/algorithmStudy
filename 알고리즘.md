## 알고리즘 개요

알고리즘을 학습하기 전에 알고리즘 구현을 위한 자원이 매우 희박한 상태라는 점을 기억해야 한다.

알고리즘을 작성하려면 시간과 공간이 매우 필요한데, 이 두 가지야 말로 알고리즘의 가장 중요한 자원이다.

특히, 우리는 문제의 규모를 측정할 때 이에 투자해야 할 자원의 양을 설명하기 위한 함수의 점근 행동([asymtotic behavior](https://www.sciencedirect.com/topics/mathematics/asymptotic-behaviour))에 관심을 갖는다.

점근 행동은 두 개의 알고리즘 기법을 비교하는 기초 자료가 되기도 하며, 특히 문제 해결을 위한 함수의 크기가 커지는 속도보다 자원 소모의 속도가 느리게 증가하는가를 확인할 수 있는 중요한 잣대이기도 하다.

이 말은 좋은 알고리즘이라면 규모가 큰 문제일수록 좀 더 신속하게 해결해야 함을 의미한다.

## Swift에서의 데이터 타입

다른 프로그래밍 언어에서는 데이터에서 기본 제공하는 원천적인 데이터 타입이 있다. 원천적인 데이터란 단일 값을 지니는 스칼라 타입을 일컫는 경우가 많다.

하지만 스위프트에서 원천 데이터 타입은 스칼라 타입으로 구현돼 있지 않다.

스위프트 데이터 타입은 다른 프로그래밍 언어와 어떤 차이가 있는지 알아보자.


## [Value type & Reference type](https://gaeng2y.medium.com/value-reference-type-756f5bdda0b5)

스위프트의 기본 데이터 타입은 밸류 타입과 레퍼런스 타입 두 가지다.

밸류 타입은 오직 하나의 소유 객체만을 지니며, 해당 타입의 데이터가 변수 또는 상수에 할당됐을 때 혹은 함수에 전달됐을 때, 지니고 있던 값을 복사한다.

밸류 타입에는 다시 구조체와 열거형, 두 가지 유형이 있으며, 스위프트의 모든 데이터 타입은 기본적으로 구조체다.

반면, 레퍼런스 타입은 밸류 타입과 달리 값을 복사하지 않고 공유한다.

즉, 레퍼런스 타입은 변수에 할당하거나 함수에 전달할 때 값을 복사해서 제공하는 대신, 동일한 인스턴스를 참조값으로 활용한다.

레퍼런스 타입은 여러 개의 소유 객체가 참조라는 방식으로 공유할 수 있다.

스위프트의 표준 라이브러리에는 Int, Double, Float, String, Character 등 다양한 네이티브 데이터 타입이 정의돼 있다.

여기서 주의할 점은 이들 데이터 타입은 다른 언어에서와 같은 원천 데이터 타입은 아니라는 것이다.

이들 데이터 타입은 스위프트 표준 라이브러리에서 구조체 타입으로 정의되고 구현된 기명 타입이다.

## 기명 타입과 복합 타입

스위프트의 또 다른 데이터 타입 분류 체계는 기명 타입(named types)과 복합 타입(compound types)이다.

**기명 타입**

사용자가 정의할 수 있는 데이터 타입이자, 해당 타입이 정의될 당시 특정한 이름을 부여할 수 있는 타입이다.

기명 타입에는 클래스, 구조체, 열거형, 프로토타입이 있다.

이들 사용자 정의 기명 타입 외에 스위프트 라이브러리에는 배열, 딕셔너리, 세트, 옵셔널 값을 나타낼 수 있는 기명 타입이 별도로 마련돼 있다.

또한 기명 타입은 Extension을 통해 동작 범위를 확장할 수 있다.

**복합 타입**

복합 타입은 별도의 이름이 붙여지지 않은 타입이며, 스위프트에는 function 타입과 type 타입 등 두 개의 복합 타입이 정의돼 있다.

복합 타입은 기명 타입과 또 다른 복합 타입을 포함할 수 있다.

예를 들어, 튜플 타입은 두 개의 요소를 포함한다.

첫 번째 요소는 Int라는 기명 타입이고, 두 번째 요소는 (Float, Float)라는 복합 타입이다.
`(Int, (Float, Float))`

## Type alias

타입 에일리어스는 기존의 타입을 또 다른 이름으로 부를 수 있는 방법을 제공한다.

스위프트의 typealias 키워드는 C 기반의 typedef와 유사하다고 할 수 있다.

## 스위프트 표준 라이브러리의 컬렉션 타입

스위프트는 배열, 딕셔너리, 세트 세 가지의 컬렉션 타입을 제공한다.

이 외에도, 정식 컬렉션 타입은 아니지만, 수, 문자열 등 복합적인 값을 한꺼번에 묶어서 편리하게 사용할 수 있는 튜플도 있다.

튜플에서 정렬된 값은 어떤 타입이라도 가능하고, 한 묶음 내의 값이 서로 같을 필요도 없다.

# 점근적 분석

서비스를 개발하는 데 있어 원하는 정보를 신속하게 찾아내는 일은 무척 중요하며, 그렇지 못할 경우 해당 서비스 또는 제품은 얼마 못가 성공 또는 실패의 기로에 서게 될 것이다.

하지만 어떤 데이터 구조 또는 알고리즘도 모든 비즈니스 상황에서 최적의 성능을 제공하지 못한다.

그래서 우리는 과연 어떤 데이터 구조 또는 알고리즘이 최적의 성능을 낼 수 있는지 확인하기 위해 알기로즘의 실행 속도를 측정한다.

입력값이 소규모일 때는 어떤 알고리즘을 쓰더라도 일정 수준 이상의 속도 또는 효율성을 기대할 수 있다.

하지만, 우리가 알고리즘의 실행 비용 또는 복잡성의 측정에 대한 이야기를 꺼낼 때는 입력값이 상당히 큰 규모임을 의미한다.

무한대에 가까운 입력값을 분석하는 데 걸리는 시간을 측정하는 방법이 바로 점근적 분석이고, 이런 분석을 통해 아래와 같은 답을 얻을 수 있다.

* (데이터가 폭주하는) 최악의 상황이라면, 얼마만큼의 저장 공간이 필요한가?
* 알고리즘이 특정 규모의 입력값을 처리하는 데 걸리는 시간은 얼마인가?
* 과연 그 문제를 해결할 수 있는가?

예를 들어, 숫자 목록을 정렬하는 함수의 실행 시간을 분석하려고 할 때, 입력 데이터의 크기에 따라 함수의 실행 시간이 얼마나 길어질지 알아야 한다.

만약, 정렬 알고리즘의 성능을 비교하기 위해, 먼저 일반벅인 삽입형 정렬 알고리즘(insertion sort)의 실행 시간을 계산하는 함수 T(n)이 있다고 했을 때,

`T(n) = c * n^2 + K`

이고, 이때 상수 c와 K는 실행 시간의 이차 함수를 나타낸다.

이에 대한 비교 대상으로, 병합형 정렬 알고리즘(merge sort)의 실행 시간을 계산하는 함수 T(n)이 있다고 했을 때,

`T(n) = c * nlog2(n) + k`

이며, 이때 상수 c와 k는 실행 시간의 리니어리드믹 함수를 나타낸다.

보통의 경우, 작은 x 값은 무시하는 경향이 있는데, 알고리즘 실행 속도의 저하 여부를 판단할 때는 대규모의 x 값이 의미가 있기 때문이다.

병합형 정렬 함수 f(x), 즉 `f(x) = c * xlog2(x) + k`의 점근적 행동이란 x 값이 커짐에 따른 f(x)의 증가 속도를 의미한다.

반드시 적용되는 규칙은 아니지만, 일반적으로 점근적 성장 속도가 느릴수록 알고리즘의 성능이 좋은 것으로 판단한다.

이런 기준에 따르면, 선형 알고리즘인 `f(x) = dx + k`는 리니어리드믹 알고리즘인 `f(y) = c * xlog2(y) + q`보다 항상 점근적 분석에서 좀 더 좋은 평가를 받는다.

이는 c, d, k, 그리고 q가 0보다 크다는 동일한 조건에서 f(y)가 f(x)에 비해 변화에 훨씬 크게 반응하기 때문이다.

## 데이터 크기 분석 방법



